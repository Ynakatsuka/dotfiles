#
# Executes commands at the start of an interactive session.
#
# Authors:
#   Sorin Ionescu <sorin.ionescu@gmail.com>
#

# Source Prezto.
if [[ -s "${ZDOTDIR:-$HOME}/.zprezto/init.zsh" ]]; then
  source "${ZDOTDIR:-$HOME}/.zprezto/init.zsh"
fi

# Customize to your needs...

#
# Prompt
#
export LSCOLORS=gxfxcxdxbxegedabagacad

# Google Cloud config info for prompt
setopt PROMPT_SUBST  # Enable command substitution in prompts

gcloud_prompt_info() {
  local config_path="$HOME/.config/gcloud/active_config"
  [[ -r "$config_path" ]] || return
  local config
  config=$(<"$config_path") || return
  config=${config//$'\n'/}
  [[ -n "$config" ]] && print " [%F{220}$config%f]"
}

# Fast custom prompt function to show truncated path with ellipsis
custom_pwd() {
  local pwd_length=3  # Number of directories to show
  local current_dir="$PWD"
  
  # Replace home directory with ~
  if [[ "$current_dir" == "$HOME"* ]]; then
    current_dir="~${current_dir#$HOME}"
  fi
  
  # Split path into array using zsh built-in
  local -a path_parts
  path_parts=(${(s:/:)current_dir})
  
  # If path is short enough, return as is
  if (( ${#path_parts} <= $((pwd_length + 1)) )); then
    echo "$current_dir"
  else
    # Take last pwd_length parts using zsh array slicing
    local short_path="${(j:/:)path_parts[-$pwd_length,-1]}"
    echo "~/.../$short_path"
  fi
}

case "$OSTYPE" in
  linux*)
    export PROMPT='%F{82}%n@%m%f:%F{63}$(custom_pwd)%f$(gcloud_prompt_info)$ '
    ;;
  *)
    export PROMPT='%F{141}%n@%m%f:%F{39}$(custom_pwd)%f$(gcloud_prompt_info)$ '
    ;;
esac

#
# Locale
#
export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
export LANGUAGE=en_US.UTF-8

#
# Alias
#

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

# docker alias
alias dc='docker compose'
alias dcps='docker compose ps'
alias dcud='docker compose up -d'
alias dcudb='docker compose up -d --build'
alias dcudf='docker compose up -d --force-recreate'
alias dce='docker compose exec $(docker compose ps --services)'
alias dcl='docker compose logs'
alias dcd='docker compose down'
alias de='docker exec -it $(docker ps | fzf | awk "{print \$1}") /bin/bash'

# gcloud
alias gca='gcloud config configurations activate'
alias gcl='gcloud config configurations list'
alias gal='gcloud auth application-default login'
alias gcsp='gcloud config set project'

# codex
alias co='codex'

#
# Git
#

# git checkout lb
alias -g lb='`git branch | fzf --prompt="GIT BRANCH> " --height=40% --reverse | head -n 1 | sed -e "s/^\*\s*//g"`'

# Git worktree
alias gwt='git worktree'
alias gwta='git worktree add'
alias gwtl='git worktree list'
alias gwtr='git worktree remove'

#
# Git Worktree Management
#

# Helper function to handle direnv setup in worktree
_gw_setup_direnv() {
    if [ -f ".envrc" ] && command -v direnv >/dev/null 2>&1; then
        echo "Found .envrc file. Allowing direnv..."
        direnv allow
    fi
}

# Helper function to open Cursor if available
_gw_open_cursor() {
    if command -v cursor >/dev/null 2>&1; then
        echo "Opening Cursor..."
        cursor .
    fi
}

# Helper function to copy .env file from original repository
_gw_copy_env() {
    local original_git_root="$1"
    
    if [ -f "$original_git_root/.env" ] && [ ! -f ".env" ]; then
        echo "Found .env file in original repository. Copying to worktree..."
        cp "$original_git_root/.env" .
    fi
}

# Smart git worktree function for InsightX
function gw() {
    local branch_name=$1
    local git_root=$(git rev-parse --show-toplevel 2>/dev/null)

    # Check if we're in a git repository
    if [ -z "$git_root" ]; then
        echo "Error: not a git repository"
        return 1
    fi

    local repo_name=$(basename "$git_root")
    local worktree_base="${git_root}-worktree"
    local base_branch="staging"

    # å¼•æ•°ãŒãªã„å ´åˆã¯fzfã§worktreeä¸€è¦§ã‹ã‚‰é¸æŠ
    if [ -z "$branch_name" ]; then
        local selected_worktree=$(git worktree list | fzf --height=40% --reverse --preview='echo "Branch: $(basename $(echo {} | awk "{print \$1}"))"' | awk '{print $1}')
        if [ -n "$selected_worktree" ]; then
            echo "Moving to worktree: $selected_worktree"
            cd "$selected_worktree"

            # .envãƒ•ã‚¡ã‚¤ãƒ«ã€direnvè¨­å®šã¨Cursorã‚’é–‹ãå‡¦ç†
            _gw_copy_env "$git_root"
            _gw_setup_direnv
            _gw_open_cursor
            return 0
        else
            echo "No worktree selected"
            return 1
        fi
    fi

    # worktreeç”¨ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹
    local worktree_dir="${worktree_base}/${branch_name//\//-}"

    # ã™ã§ã«worktreeãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ (Fix grep option parsing issue)
    if git worktree list | grep -qF "$worktree_dir"; then
        echo "Worktree already exists at: $worktree_dir"
        echo "Changing directory to existing worktree..."
        cd "$worktree_dir"

        # .envãƒ•ã‚¡ã‚¤ãƒ«ã€direnvè¨­å®šã¨Cursorã‚’é–‹ãå‡¦ç†
        _gw_copy_env "$git_root"
        _gw_setup_direnv
        _gw_open_cursor
        return 0
    fi

    # Update staging branch to latest remote
    echo "Updating $base_branch branch to latest remote..."
    git fetch origin "$base_branch"

    # Check if staging branch exists locally
    if ! git show-ref --verify --quiet "refs/heads/$base_branch"; then
        # If local staging doesn't exist, create it from remote
        git branch "$base_branch" "origin/$base_branch"
    else
        # If staging is checked out in a worktree, update it there
        local staging_worktree=$(git worktree list --porcelain | awk '/^worktree/ {wt=$2} /^branch refs\/heads\/'"$base_branch"'$/ {print wt; exit}')
        if [ -n "$staging_worktree" ]; then
            echo "Updating $base_branch in worktree: $staging_worktree"
            (cd "$staging_worktree" && git pull origin "$base_branch")
        else
            # If staging exists but not in a worktree, force update it
            git branch -f "$base_branch" "origin/$base_branch"
        fi
    fi

    local new_worktree_created=false

    # ç¾åœ¨ã®ãƒ–ãƒ©ãƒ³ãƒã¨åŒã˜åå‰ã®å ´åˆã¯æ–°ã—ã„worktreeã‚’ä½œæˆ
    current_branch=$(git branch --show-current)
    if [ "$branch_name" = "$current_branch" ]; then
        echo "Creating worktree for current branch: $branch_name from $base_branch"
        git worktree add "$worktree_dir" "$branch_name"
        cd "$worktree_dir"
        new_worktree_created=true
    # å­˜åœ¨ã™ã‚‹ãƒ–ãƒ©ãƒ³ãƒã®å ´åˆã¯worktreeã‚’ä½œæˆ
    elif git show-ref --verify --quiet "refs/heads/$branch_name" || git show-ref --verify --quiet "refs/remotes/origin/$branch_name"; then
        echo "Creating worktree for existing branch: $branch_name from $base_branch"
        git worktree add "$worktree_dir" "$branch_name"
        cd "$worktree_dir"
        new_worktree_created=true
    # å­˜åœ¨ã—ãªã„ãƒ–ãƒ©ãƒ³ãƒã®å ´åˆã¯stagingã‹ã‚‰æ–°ã—ã„ãƒ–ãƒ©ãƒ³ãƒã‚’ä½œæˆ
    else
        echo "Creating new branch '$branch_name' from $base_branch and worktree"
        git worktree add -b "$branch_name" "$worktree_dir" "$base_branch"
        cd "$worktree_dir"
        new_worktree_created=true
    fi

    # æ–°ã—ã„worktreeãŒä½œæˆã•ã‚ŒãŸå ´åˆã®å‡¦ç†
    if [ "$new_worktree_created" = true ]; then
        # .envãƒ•ã‚¡ã‚¤ãƒ«ã€direnvè¨­å®šã¨Cursorã‚’é–‹ãå‡¦ç†
        _gw_copy_env "$git_root"
        _gw_setup_direnv
        _gw_open_cursor
    fi
}

# Git worktree cleanup function
function gwc() {
    local git_root=$(git rev-parse --show-toplevel 2>/dev/null)
    local repo_name=$(basename "$git_root")
    local worktree_base="${git_root}-worktree"

    # ç¾åœ¨ã®worktreeä¸€è¦§ã‚’å–å¾—ï¼ˆãƒ¡ã‚¤ãƒ³ãƒªãƒã‚¸ãƒˆãƒªä»¥å¤–ï¼‰
    local worktrees=$(git worktree list | grep -v "$(git rev-parse --show-toplevel)$")

    if [ -z "$worktrees" ]; then
        echo "å‰Šé™¤å¯èƒ½ãªworktreeãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
        return 1
    fi

    # fzfã§worktreeã‚’é¸æŠï¼ˆè§’æ‹¬å¼§ã‚’é™¤å»ã€è¤‡æ•°é¸æŠå¯èƒ½ï¼‰
    local selected_lines=$(echo "$worktrees" | sed 's/\[//g; s/\]//g' | fzf \
        -m \
        --height=60% \
        --reverse \
        --prompt="å‰Šé™¤ã™ã‚‹worktreeã‚’é¸æŠ (Tab: è¤‡æ•°é¸æŠ): " \
        --header="Tab: é¸æŠ/è§£é™¤, Enter: ç¢ºå®š")

    if [ -z "$selected_lines" ]; then
        echo "worktreeãŒé¸æŠã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ"
        return 1
    fi

    # é¸æŠã•ã‚ŒãŸworktreeã®æƒ…å ±ã‚’é…åˆ—ã«æ ¼ç´
    local -a worktree_paths
    local -a branch_names
    while IFS= read -r line; do
        worktree_paths+=("$(echo "$line" | awk '{print $1}')")
        branch_names+=("$(echo "$line" | awk '{print $2}')")
    done <<< "$selected_lines"

    # ç¢ºèªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
    echo "å‰Šé™¤äºˆå®šã®worktree (${#worktree_paths[@]}ä»¶):"
    for i in {1..${#worktree_paths[@]}}; do
        echo "  [$i] ãƒ‘ã‚¹: ${worktree_paths[$i]}"
        echo "      ãƒ–ãƒ©ãƒ³ãƒ: ${branch_names[$i]}"
    done
    echo -n "æœ¬å½“ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ (y/N): "
    read confirmation

    if [[ "$confirmation" =~ ^[yY]$ ]]; then
        local success_count=0
        local fail_count=0

        # worktreeã‚’ä¸€ã¤ãšã¤å‰Šé™¤
        for i in {1..${#worktree_paths[@]}}; do
            local worktree_path="${worktree_paths[$i]}"
            local branch_name="${branch_names[$i]}"

            echo ""
            echo "[$i/${#worktree_paths[@]}] worktreeã‚’å‰Šé™¤ä¸­: $worktree_path"
            if git worktree remove "$worktree_path" --force; then
                echo "âœ… worktreeãŒå‰Šé™¤ã•ã‚Œã¾ã—ãŸ: $worktree_path"
                ((success_count++))

                # ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒæ®‹ã£ã¦ã„ã‚‹å ´åˆã¯å‰Šé™¤
                if [ -d "$worktree_path" ]; then
                    echo "ğŸ“‚ æ®‹ã‚Šã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’å‰Šé™¤ä¸­..."
                    rm -rf "$worktree_path"
                fi
            else
                echo "âŒ worktreeã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ: $worktree_path"
                ((fail_count++))
            fi
        done

        echo ""
        echo "=========================================="
        echo "å‰Šé™¤å®Œäº†: æˆåŠŸ $success_count ä»¶, å¤±æ•— $fail_count ä»¶"
        echo "=========================================="

        if [ $fail_count -gt 0 ]; then
            return 1
        fi
    else
        echo "å‰Šé™¤ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ"
        return 0
    fi
}

#
# Codex Integration
#

# Internal helper: portable dev:inode fetch
_codex_devino() {
  if stat -c '%d:%i' "$1" >/dev/null 2>&1; then
    stat -c '%d:%i' "$1"
  else
    stat -f '%d:%i' "$1"
  fi
}

# Core sync helper
_codex_sync_impl() {
  local src="$1" dest="$2"
  if [ ! -d "$src" ]; then
    echo "Source directory not found: $src" >&2
    return 1
  fi
  mkdir -p "$dest"
  local src_real dest_real
  src_real=$(readlink -f "$src" 2>/dev/null || printf %s "$src")
  dest_real=$(readlink -f "$dest" 2>/dev/null || printf %s "$dest")
  if [ -d "$dest_real" ] && [ "$(_codex_devino "$src_real")" = "$(_codex_devino "$dest_real")" ]; then
    echo "Source and destination refer to the same directory; nothing to do."
    return 0
  fi
  if command -v rsync >/dev/null 2>&1; then
    rsync -av --delete "$src_real"/ "$dest_real"/
  else
    find "$dest_real" -mindepth 1 -maxdepth 1 -exec rm -rf {} +
    cp -a "$src_real"/. "$dest_real"/
  fi
  echo "Synced: $src_real -> $dest_real"
}

# Flattening sync helper: subdir/file.md -> subdir-file.md
_codex_flatten_sync_impl() {
  local src="$1" dest="$2"
  if [ ! -d "$src" ]; then
    echo "Source directory not found: $src" >&2
    return 1
  fi
  mkdir -p "$dest"
  local src_real dest_real
  src_real=$(readlink -f "$src" 2>/dev/null || printf %s "$src")
  dest_real=$(readlink -f "$dest" 2>/dev/null || printf %s "$dest")

  # å®‰å…¨å¯¾ç­–: åŒä¸€ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæŒ‡ã—ç¤ºã—ã®æ—©æœŸçµ‚äº†
  if [ -d "$dest_real" ] && [ "$(_codex_devino "$src_real")" = "$(_codex_devino "$dest_real")" ]; then
    echo "Source and destination refer to the same directory; aborting to avoid self-sync." >&2
    echo "  src:  $src_real" >&2
    echo "  dest: $dest_real" >&2
    echo "Hint: å¼•æ•°ã§åˆ¥ã®å‡ºåŠ›å…ˆã‚’æŒ‡å®šã™ã‚‹ã‹ã€ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã‚’å¤–ã—ã¦ãã ã•ã„ã€‚" >&2
    return 1
  fi

  # ãƒŸãƒ©ãƒ¼ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã«åˆã‚ã›ã¦å‡ºåŠ›å´ã‚’ã‚¯ãƒªã‚¢ï¼ˆrsync --delete ç›¸å½“ï¼‰
  find "$dest_real" -mindepth 1 -maxdepth 1 -exec rm -rf {} +

  # å†å¸°çš„ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åˆ—æŒ™ã—ã€ãƒ‘ã‚¹åŒºåˆ‡ã‚Šã‚’ '-' ã«ç½®æ›ã—ã¦ã‚³ãƒ”ãƒ¼
  while IFS= read -r -d '' file; do
    local rel flattened target base ext n src_base
    rel=${file#"$src_real/"}
    flattened=${rel//\//-}

    # src ãŒã‚³ãƒãƒ³ãƒ‰ç›´ä¸‹ï¼ˆ.../.claude/commandsï¼‰ã§ãªã„å ´åˆã¯ã€
    # å¸¸ã« src ã®ãƒ™ãƒ¼ã‚¹åã‚’æ¥é ­è¾ã¨ã—ã¦ä»˜ä¸ï¼ˆä¾‹: src=.../mtg -> mtg-* / src=.../kiro -> kiro-*ï¼‰ã€‚
    # commands ç›´ä¸‹ã‚’ src ã«æŒ‡å®šã—ã¦ã„ã‚‹å ´åˆã¯ã€ã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåï¼ˆmtg/kiro/...) ãŒæ—¢ã«å…ˆé ­ã«å…¥ã‚‹ã®ã§ä»˜ä¸ã—ãªã„ã€‚
    src_base=$(basename "$src_real")
    if [[ "$src_base" != "commands" && "$flattened" != ${src_base}-* ]]; then
      flattened="${src_base}-${flattened}"
    fi

    target="$dest_real/$flattened"

    # åå‰è¡çªæ™‚ã¯ -2, -3 ... ã¨é€£ç•ªã‚’ä»˜ä¸
    if [ -e "$target" ]; then
      if [[ "$flattened" == *.* ]]; then
        base="${flattened%.*}"; ext=".${flattened##*.}"
      else
        base="$flattened"; ext=""
      fi
      n=2
      while [ -e "$dest_real/${base}-${n}${ext}" ]; do n=$((n+1)); done
      target="$dest_real/${base}-${n}${ext}"
    fi

    cp -a "$file" "$target"
  done < <(find "$src_real" -type f -print0)

  echo "Flatten-synced: $src_real -> $dest_real"
}

# Default repo sync
codex-sync() {
  local guessed_src
  if git_root=$(git rev-parse --show-toplevel 2>/dev/null); then
    guessed_src="$git_root/.claude/commands"
  fi
  local fallback_src="/home/claude-code/Documents/src/github.com/Revie0701/insightx/.claude/commands"
  local src="${1:-${guessed_src:-$fallback_src}}"
  local dest="${2:-$HOME/.codex/prompts}"
  _codex_flatten_sync_impl "$src" "$dest"
}

#
# Fzf Integration
#

# fzf history
function fzf-select-history() {
    BUFFER=$(history -n -r 1 | fzf --query "$LBUFFER" --reverse)
    CURSOR=$#BUFFER
    zle reset-prompt
}
zle -N fzf-select-history
bindkey '^r' fzf-select-history

# cdr
autoload -Uz is-at-least
if is-at-least 4.3.11
then
  autoload -Uz chpwd_recent_dirs cdr add-zsh-hook
  add-zsh-hook chpwd chpwd_recent_dirs
  zstyle ':chpwd:*'      recent-dirs-max 500
  zstyle ':chpwd:*'      recent-dirs-default yes
  zstyle ':completion:*' recent-dirs-insert both
fi

# fzf cdr
function fzf-cdr() {
    local selected_dir=$(cdr -l | awk '{ print $2 }' | fzf --reverse)
    if [ -n "$selected_dir" ]; then
        BUFFER="cd ${selected_dir}"
        zle accept-line
    fi
    zle clear-screen
}
zle -N fzf-cdr
setopt noflowcontrol
bindkey '^q' fzf-cdr

# fzf gcloud configuration select and login
function gcloud-fzf-activate-login() {
    local config
    config=$(gcloud config configurations list --format="value(NAME)" | fzf --prompt="GCloud Config> " --height=40% --reverse)
    if [ -n "$config" ]; then
        gcloud config configurations activate "$config"
        gcloud auth application-default login
    fi
}
zle -N gcloud-fzf-activate-login
bindkey '^g' gcloud-fzf-activate-login

# fzf ghq repository select
function fzf-ghq-src () {
  local selected_dir=$(ghq list -p | fzf --prompt="repositories >" --query "$LBUFFER" --height=40% --reverse)
  if [ -n "$selected_dir" ]; then
    BUFFER="cd ${selected_dir}"
    zle accept-line
  fi
  zle clear-screen
}
zle -N fzf-ghq-src
bindkey '^h' fzf-ghq-src

#
# Copy Last Output
#
function copy_last_output() {
  local lastcmd=$(fc -ln -20 | grep -v 'copy_last_output' | grep -v '^[[:space:]]*$' | tail -n 1)
  if [[ -z "$lastcmd" ]]; then
    echo "No previous command found."
    return 1
  fi

  local output
  output=$(eval "$lastcmd" 2>&1)
  echo "$lastcmd"$'\n'"$output" | pbcopy
}
zle -N copy_last_output
bindkey '^o' copy_last_output

#
# Claude Code
#
function cl() {
    git_root=$(git rev-parse --show-toplevel 2>/dev/null)
    if [ -f "$git_root/.claude/mcp.json" ]; then
        claude --mcp-config="$git_root/.claude/mcp.json" "$@" "--dangerously-skip-permissions"
    else
        claude "$@" "--dangerously-skip-permissions"
    fi
}

#
# Path
#

# cache directory
[[ -d "$HOME/.zsh/cache" ]] || mkdir -p "$HOME/.zsh/cache"

# iterm2
test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh" || true

# cuda
if [ -d "/usr/local/cuda/bin" ]; then
    export PATH="/usr/local/cuda/bin:$PATH"
    export LD_LIBRARY_PATH="/usr/local/cuda/lib64:$LD_LIBRARY_PATH"
fi

# .local
export PATH="$HOME/.local/bin:$PATH"

# docker build
if [[ $(uname -m) == "arm64" ]]; then
  export DOCKER_DEFAULT_PLATFORM=linux/amd64
fi

# go
export GOPATH=$HOME/go
export PATH=$PATH:$GOPATH/bin

# volta
export VOLTA_HOME="$HOME/.volta"
export PATH="$VOLTA_HOME/bin:$PATH"

# initialize runtime tools
autoload -Uz add-zsh-hook

_initialize_runtime_tools() {
  add-zsh-hook -d precmd _initialize_runtime_tools
  # rye
  if [[ -f "$HOME/.rye/env" ]]; then
    source "$HOME/.rye/env"
  fi

  # mise
  if command -v mise > /dev/null 2>&1; then
    eval "$(mise activate zsh)"
  fi

  # direnv
  if type direnv > /dev/null 2>&1; then
      eval "$(direnv hook zsh)"
  fi
}

add-zsh-hook precmd _initialize_runtime_tools
