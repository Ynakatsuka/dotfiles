#
# Executes commands at the start of an interactive session.
#
# Authors:
#   Sorin Ionescu <sorin.ionescu@gmail.com>
#

# Source Prezto.
if [[ -s "${ZDOTDIR:-$HOME}/.zprezto/init.zsh" ]]; then
  source "${ZDOTDIR:-$HOME}/.zprezto/init.zsh"
fi

# Customize to your needs...

#
# Prompt
#
export LSCOLORS=gxfxcxdxbxegedabagacad

# Google Cloud config info for prompt
setopt PROMPT_SUBST  # Enable command substitution in prompts

gcloud_prompt_info() {
  local config_path="$HOME/.config/gcloud/active_config"
  [[ -r "$config_path" ]] || return
  local config
  config=$(<"$config_path") || return
  config=${config//$'\n'/}
  [[ -n "$config" ]] && print " [%F{220}$config%f]"
}

# Fast custom prompt function to show truncated path with ellipsis
custom_pwd() {
  local pwd_length=3  # Number of directories to show
  local current_dir="$PWD"
  
  # Replace home directory with ~
  if [[ "$current_dir" == "$HOME"* ]]; then
    current_dir="~${current_dir#$HOME}"
  fi
  
  # Split path into array using zsh built-in
  local -a path_parts
  path_parts=(${(s:/:)current_dir})
  
  # If path is short enough, return as is
  if (( ${#path_parts} <= $((pwd_length + 1)) )); then
    echo "$current_dir"
  else
    # Take last pwd_length parts using zsh array slicing
    local short_path="${(j:/:)path_parts[-$pwd_length,-1]}"
    echo "~/.../$short_path"
  fi
}

case "$OSTYPE" in
  linux*)
    export PROMPT='%F{82}%n@%m%f:%F{63}$(custom_pwd)%f$(gcloud_prompt_info)$ '
    ;;
  *)
    export PROMPT='%F{141}%n@%m%f:%F{39}$(custom_pwd)%f$(gcloud_prompt_info)$ '
    ;;
esac

#
# Locale
#
export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
export LANGUAGE=en_US.UTF-8

#
# Alias
#

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

# docker alias
alias dc='docker compose'
alias dcps='docker compose ps'
alias dcud='docker compose up -d'
alias dcudb='docker compose up -d --build'
alias dcudf='docker compose up -d --force-recreate'
alias dce='docker compose exec $(docker compose ps --services)'
alias dcl='docker compose logs'
alias dcd='docker compose down'

# gcloud
alias gca='gcloud config configurations activate'
alias gcl='gcloud config configurations list'
alias gal='gcloud auth application-default login'
alias gcsp='gcloud config set project'

# claude code
alias cl='claude'

# codex
alias co='codex'

# Git worktree
alias gwt='git worktree'
alias gwta='git worktree add'
alias gwtl='git worktree list'
alias gwtr='git worktree remove'

#
# Git Worktree Management
#

# Smart git worktree function for InsightX
function gw() {
    local branch_name=$1
    local git_root=$(git rev-parse --show-toplevel 2>/dev/null)
    local repo_name=$(basename "$git_root")
    local worktree_base="$HOME/.worktree/${repo_name}"

    # å¼•æ•°ãŒãªã„å ´åˆã¯fzfã§worktreeä¸€è¦§ã‹ã‚‰é¸æŠ
    if [ -z "$branch_name" ]; then
        local selected_worktree=$(git worktree list | fzf --height=40% --reverse --preview='echo "Branch: $(basename $(echo {} | awk "{print \$1}"))"' | awk '{print $1}')
        if [ -n "$selected_worktree" ]; then
            echo "Moving to worktree: $selected_worktree"
            cd "$selected_worktree"
            return 0
        else
            echo "No worktree selected"
            return 1
        fi
    fi

    # worktreeç”¨ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹
    local worktree_dir="${worktree_base}/${branch_name//\//-}"

    # ã™ã§ã«worktreeãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    if git worktree list | grep -q "$worktree_dir"; then
        echo "Worktree already exists at: $worktree_dir"
        echo "Changing directory to existing worktree..."
        cd "$worktree_dir"
        return 0
    fi

    local new_worktree_created=false

    # ç¾åœ¨ã®ãƒ–ãƒ©ãƒ³ãƒã¨åŒã˜åå‰ã®å ´åˆ
    current_branch=$(git branch --show-current)
    if [ "$branch_name" = "$current_branch" ]; then
        echo "Creating worktree for current branch: $branch_name"
        git worktree add "$worktree_dir" "$branch_name"
        cd "$worktree_dir"
        new_worktree_created=true
    elif git show-ref --verify --quiet "refs/heads/$branch_name" || git show-ref --verify --quiet "refs/remotes/origin/$branch_name"; then
        echo "Creating worktree for existing branch: $branch_name"
        git worktree add "$worktree_dir" "$branch_name"
        cd "$worktree_dir"
        new_worktree_created=true
    else
        echo "Creating new branch and worktree: $branch_name"
        git worktree add -b "$branch_name" "$worktree_dir"
        cd "$worktree_dir"
        new_worktree_created=true
    fi
}

# Git worktree cleanup function
function gwc() {
    local git_root=$(git rev-parse --show-toplevel 2>/dev/null)
    local repo_name=$(basename "$git_root")
    local worktree_base="$HOME/.worktree/${repo_name}"

    # ç¾åœ¨ã®worktreeä¸€è¦§ã‚’å–å¾—ï¼ˆãƒ¡ã‚¤ãƒ³ãƒªãƒã‚¸ãƒˆãƒªä»¥å¤–ï¼‰
    local worktrees=$(git worktree list | grep -v "$(git rev-parse --show-toplevel)$")

    if [ -z "$worktrees" ]; then
        echo "å‰Šé™¤å¯èƒ½ãªworktreeãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
        return 1
    fi

    # fzfã§worktreeã‚’é¸æŠï¼ˆè§’æ‹¬å¼§ã‚’é™¤å»ï¼‰
    local selected_line=$(echo "$worktrees" | sed 's/\[//g; s/\]//g' | fzf \
        --height=60% \
        --reverse \
        --prompt="å‰Šé™¤ã™ã‚‹worktreeã‚’é¸æŠ: ")

    if [ -z "$selected_line" ]; then
        echo "worktreeãŒé¸æŠã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ"
        return 1
    fi

    # é¸æŠã•ã‚ŒãŸworktreeã®ãƒ‘ã‚¹ã‚’å–å¾—
    local worktree_path=$(echo "$selected_line" | awk '{print $1}')
    local branch_name=$(echo "$selected_line" | awk '{print $2}')

    # ç¢ºèªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
    echo "å‰Šé™¤äºˆå®šã®worktree:"
    echo "  ãƒ‘ã‚¹: $worktree_path"
    echo "  ãƒ–ãƒ©ãƒ³ãƒ: $branch_name"
    echo -n "æœ¬å½“ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ (y/N): "
    read confirmation

    if [[ "$confirmation" =~ ^[yY]$ ]]; then
        # worktreeã‚’å‰Šé™¤
        echo "worktreeã‚’å‰Šé™¤ä¸­..."
        if git worktree remove "$worktree_path" --force; then
            echo "âœ… worktreeãŒå‰Šé™¤ã•ã‚Œã¾ã—ãŸ: $worktree_path"

            # ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒæ®‹ã£ã¦ã„ã‚‹å ´åˆã¯éåŒæœŸã§å‰Šé™¤
            if [ -d "$worktree_path" ]; then
                echo "ğŸ“‚ æ®‹ã‚Šã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’å‰Šé™¤ä¸­..."
                rm -rf "$worktree_path"
            fi
        else
            echo "âŒ worktreeã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ"
            return 1
        fi
    else
        echo "å‰Šé™¤ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ"
        return 0
    fi
}

#
# Codex Integration
#

# Internal helper: portable dev:inode fetch
_codex_devino() {
  if stat -c '%d:%i' "$1" >/dev/null 2>&1; then
    stat -c '%d:%i' "$1"
  else
    stat -f '%d:%i' "$1"
  fi
}

# Core sync helper
_codex_sync_impl() {
  local src="$1" dest="$2"
  if [ ! -d "$src" ]; then
    echo "Source directory not found: $src" >&2
    return 1
  fi
  mkdir -p "$dest"
  local src_real dest_real
  src_real=$(readlink -f "$src" 2>/dev/null || printf %s "$src")
  dest_real=$(readlink -f "$dest" 2>/dev/null || printf %s "$dest")
  if [ -d "$dest_real" ] && [ "$(_codex_devino "$src_real")" = "$(_codex_devino "$dest_real")" ]; then
    echo "Source and destination refer to the same directory; nothing to do."
    return 0
  fi
  if command -v rsync >/dev/null 2>&1; then
    rsync -av --delete "$src_real"/ "$dest_real"/
  else
    find "$dest_real" -mindepth 1 -maxdepth 1 -exec rm -rf {} +
    cp -a "$src_real"/. "$dest_real"/
  fi
  echo "Synced: $src_real -> $dest_real"
}

# Flattening sync helper: subdir/file.md -> subdir-file.md
_codex_flatten_sync_impl() {
  local src="$1" dest="$2"
  if [ ! -d "$src" ]; then
    echo "Source directory not found: $src" >&2
    return 1
  fi
  mkdir -p "$dest"
  local src_real dest_real
  src_real=$(readlink -f "$src" 2>/dev/null || printf %s "$src")
  dest_real=$(readlink -f "$dest" 2>/dev/null || printf %s "$dest")

  # å®‰å…¨å¯¾ç­–: åŒä¸€ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæŒ‡ã—ç¤ºã—ã®æ—©æœŸçµ‚äº†
  if [ -d "$dest_real" ] && [ "$(_codex_devino "$src_real")" = "$(_codex_devino "$dest_real")" ]; then
    echo "Source and destination refer to the same directory; aborting to avoid self-sync." >&2
    echo "  src:  $src_real" >&2
    echo "  dest: $dest_real" >&2
    echo "Hint: å¼•æ•°ã§åˆ¥ã®å‡ºåŠ›å…ˆã‚’æŒ‡å®šã™ã‚‹ã‹ã€ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã‚’å¤–ã—ã¦ãã ã•ã„ã€‚" >&2
    return 1
  fi

  # ãƒŸãƒ©ãƒ¼ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã«åˆã‚ã›ã¦å‡ºåŠ›å´ã‚’ã‚¯ãƒªã‚¢ï¼ˆrsync --delete ç›¸å½“ï¼‰
  find "$dest_real" -mindepth 1 -maxdepth 1 -exec rm -rf {} +

  # å†å¸°çš„ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åˆ—æŒ™ã—ã€ãƒ‘ã‚¹åŒºåˆ‡ã‚Šã‚’ '-' ã«ç½®æ›ã—ã¦ã‚³ãƒ”ãƒ¼
  while IFS= read -r -d '' file; do
    local rel flattened target base ext n src_base
    rel=${file#"$src_real/"}
    flattened=${rel//\//-}

    # src ãŒã‚³ãƒãƒ³ãƒ‰ç›´ä¸‹ï¼ˆ.../.claude/commandsï¼‰ã§ãªã„å ´åˆã¯ã€
    # å¸¸ã« src ã®ãƒ™ãƒ¼ã‚¹åã‚’æ¥é ­è¾ã¨ã—ã¦ä»˜ä¸ï¼ˆä¾‹: src=.../mtg -> mtg-* / src=.../kiro -> kiro-*ï¼‰ã€‚
    # commands ç›´ä¸‹ã‚’ src ã«æŒ‡å®šã—ã¦ã„ã‚‹å ´åˆã¯ã€ã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåï¼ˆmtg/kiro/...) ãŒæ—¢ã«å…ˆé ­ã«å…¥ã‚‹ã®ã§ä»˜ä¸ã—ãªã„ã€‚
    src_base=$(basename "$src_real")
    if [[ "$src_base" != "commands" && "$flattened" != ${src_base}-* ]]; then
      flattened="${src_base}-${flattened}"
    fi

    target="$dest_real/$flattened"

    # åå‰è¡çªæ™‚ã¯ -2, -3 ... ã¨é€£ç•ªã‚’ä»˜ä¸
    if [ -e "$target" ]; then
      if [[ "$flattened" == *.* ]]; then
        base="${flattened%.*}"; ext=".${flattened##*.}"
      else
        base="$flattened"; ext=""
      fi
      n=2
      while [ -e "$dest_real/${base}-${n}${ext}" ]; do n=$((n+1)); done
      target="$dest_real/${base}-${n}${ext}"
    fi

    cp -a "$file" "$target"
  done < <(find "$src_real" -type f -print0)

  echo "Flatten-synced: $src_real -> $dest_real"
}

# Default repo sync
codex-sync() {
  local guessed_src
  if git_root=$(git rev-parse --show-toplevel 2>/dev/null); then
    guessed_src="$git_root/.claude/commands"
  fi
  local fallback_src="/home/claude-code/Documents/src/github.com/Revie0701/insightx/.claude/commands"
  local src="${1:-${guessed_src:-$fallback_src}}"
  local dest="${2:-$HOME/.codex/prompts}"
  _codex_flatten_sync_impl "$src" "$dest"
}

#
# Fzf Integration
#

# fzf history
function fzf-select-history() {
    BUFFER=$(history -n -r 1 | fzf --query "$LBUFFER" --reverse)
    CURSOR=$#BUFFER
    zle reset-prompt
}
zle -N fzf-select-history
bindkey '^r' fzf-select-history

# fzf cdr
function fzf-cdr() {
    local selected_dir=$(cdr -l | awk '{ print $2 }' | fzf --reverse)
    if [ -n "$selected_dir" ]; then
        BUFFER="cd ${selected_dir}"
        zle accept-line
    fi
    zle clear-screen
}
zle -N fzf-cdr
setopt noflowcontrol
bindkey '^q' fzf-cdr

#
# Path
#

# cache directory
[[ -d "$HOME/.zsh/cache" ]] || mkdir -p "$HOME/.zsh/cache"

# iterm2
test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh" || true

# cuda
if [ -d "/usr/local/cuda/bin" ]; then
    export PATH="/usr/local/cuda/bin:$PATH"
    export LD_LIBRARY_PATH="/usr/local/cuda/lib64:$LD_LIBRARY_PATH"
fi

# .local
export PATH="$HOME/.local/bin:$PATH"

# docker build
if [[ $(uname -m) == "arm64" ]]; then
  export DOCKER_DEFAULT_PLATFORM=linux/amd64
fi

# go
export GOPATH=$HOME/go
export PATH=$PATH:$GOPATH/bin

# volta
export VOLTA_HOME="$HOME/.volta"
export PATH="$VOLTA_HOME/bin:$PATH"

# initialize runtime tools
autoload -Uz add-zsh-hook

_initialize_runtime_tools() {
  add-zsh-hook -d precmd _initialize_runtime_tools
  # rye
  if [[ -f "$HOME/.rye/env" ]]; then
    source "$HOME/.rye/env"
  fi

  # mise
  if command -v mise > /dev/null 2>&1; then
    eval "$(mise activate zsh)"
  fi

  # direnv
  if type direnv > /dev/null 2>&1; then
      eval "$(direnv hook zsh)"
  fi
}

add-zsh-hook precmd _initialize_runtime_tools
